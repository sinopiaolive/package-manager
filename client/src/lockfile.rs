use std::default::Default;
use std::fmt;
use std::vec::Vec;

use pm_lib::index::Dependencies;
use pm_lib::package::PackageName;
use pm_lib::version::Version;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Lockfile {
    pub meta: LockfileMeta,
    pub locked_dependencies: Vec<LockedDependency>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct LockfileMeta {
    install: Version,
    update: Version,
}

impl Default for LockfileMeta {
    fn default() -> Self {
        LockfileMeta {
            install: Version::from_str("1.0").unwrap(),
            update: Version::from_str("1.0").unwrap(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct LockedDependency {
    pub package_name: PackageName,
    pub version: Version,
    pub dependencies: Dependencies,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum LockfileEntry {
    #[serde(rename = "package_manager")]
    Meta(LockfileMeta),
    #[serde(rename = "dependency")]
    Dependency(LockedDependency),
}

#[derive(Serialize, Debug, Clone, PartialEq, Eq)]
pub enum LockfileEntryGuard<'a> {
    #[serde(rename = "package_manager")]
    Meta { },
    #[serde(rename = "dependency")]
    Dependency { package_name: &'a PackageName },
}

impl LockfileEntry {
    pub fn guard(&self) -> LockfileEntryGuard {
        match self {
            LockfileEntry::Meta(_) => LockfileEntryGuard::Meta { },
            LockfileEntry::Dependency(locked_dependency) => LockfileEntryGuard::Dependency {
                package_name: &locked_dependency.package_name,
            },
        }
    }
}

impl fmt::Display for Lockfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fn write_entry(f: &mut fmt::Formatter<'_>, lockfile_entry: &LockfileEntry) -> fmt::Result {
            let entry_string = ::serde_json::to_string(&lockfile_entry).unwrap();
            let guard_string = ::serde_json::to_string(&lockfile_entry.guard()).unwrap();
            writeln!(f, "### {}", guard_string)?;
            writeln!(f, "    {}", entry_string)?;
            writeln!(f, "  # {}", guard_string)?;
            Ok(())
        }

        writeln!(
            f,
            "### THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY."
        )?;

        let meta = LockfileEntry::Meta(self.meta.clone());
        write_entry(f, &meta)?;

        for locked_dependency in &self.locked_dependencies {
            let dependency_entry = LockfileEntry::Dependency(locked_dependency.clone());
            write_entry(f, &dependency_entry)?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use pm_lib::test_helpers::*;

    #[test]
    fn serialize() {
        let lockfile = &Lockfile {
            meta: LockfileMeta::default(),
            locked_dependencies: vec![LockedDependency {
                package_name: pkg("x"),
                version: ver("1.0.0"),
                dependencies: Dependencies::new(),
            }],
        };
        println!("{}", lockfile.to_string());

        // let out = r#""#;
        // assert_eq!(lockfile.to_string(), out);
    }
}
